# Default values for mcp-client.

# Docker image settings
image:
  repository:
  tag:
  pullPolicy:

# Client settings
client:
  host:
  port:

# Environment variables for the client
env:
  MCP_SERVER_URL:
  LLM_API_URL:
  LLM_MODEL:
  LLM_API_KEY:
  LLM_SSL_VERIFY:
  LOG_LEVEL:
  # Database connection
  DATABASE_URL: ""  # Will be constructed from other DB settings
  DATABASE_HOST: "mcp-client-postgres"  # Service name
  DATABASE_PORT: 5432
  DATABASE_NAME: "mcp_client"
  DATABASE_USER: "mcp_user"
  DATABASE_PASSWORD: ""  # Will use postgres.password

# Replicas
replicaCount:

# Resources
resources:
  limits:
    cpu:
    memory:
  requests:
    cpu:
    memory:

# Service settings
service:
  type: 
  port:
  networkPool:

# Liveness/Readiness probes for client
livenessProbe:
  httpGet:
    path: /health
    port: 8000
  initialDelaySeconds: 20
  periodSeconds: 90

readinessProbe:
  httpGet:
    path: /health
    port: 8000
  initialDelaySeconds: 10
  periodSeconds: 60

# Pod labels and annotations
podLabels: {}
podAnnotations: {}

# Node selector for pod placement
nodeSelector: {}

# Tolerations for pod assignment
tolerations: []

# Affinity for pod assignment
affinity: {}

# Security context
securityContext:
  runAsNonRoot: true
  runAsUser: 1000
  fsGroup: 1000

# Pod security context
podSecurityContext:
  fsGroup: 1000

# Ingress configuration
ingress:
  enabled: false
  className: ""
  annotations: {}
  hosts:
    - host: mcp-client.local
      paths:
        - path: /
          pathType: Prefix
  tls: []

# Autoscaling configuration
autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 10
  targetCPUUtilizationPercentage: 80
  targetMemoryUtilizationPercentage: 80

# PostgreSQL Database Configuration
postgres:
  # Database credentials
  database: mcp_client
  username: mcp_user
  password: "McpClient2025!SecurePassword"  # Change this in production!
  
  # Resource allocation
  resources:
    limits:
      cpu: 500m
      memory: 512Mi
    requests:
      cpu: 200m
      memory: 256Mi
  
  # Persistence settings
  persistence:
    enabled: true
    size: 10Gi
    # Storage class - leave empty or comment out if you don't have one
    # storageClass: "fast-ssd"  # Uncomment and set when you have a storage class
    storageClass: ""  # Empty means no storage class, will use host path
    
    # Host path settings (used when no storage class is available)
    hostPath: "/data/mcp-client-postgres"  # Path on the host where data will be stored
    nodeSelector: ""  # Specific node to run postgres on (leave empty for default)

# Authentication and Security
auth:
  # JWT token settings
  jwtSecret: "your-super-secret-jwt-key-change-in-production"  # Change this!
  accessTokenExpire: 3600  # 1 hour in seconds
  refreshTokenExpire: 604800  # 7 days in seconds
  
  # Default admin user (created automatically)
  admin:
    username: "admin"
    password: "admin123"  # Change this immediately after first login!
    email: "admin@mcp-client.local"

# Feature flags
features:
  enableUserRegistration: true
  enableGuestAccess: false
  enableMetrics: true
  enableTracing: false

# IDA MCP Configuration
idaMcp:
  # Enable IDA MCP functionality
  enabled: true
  
  # Kubernetes controller configuration
  k8s:
    # Namespace for MCP server deployments
    namespace: ""  # Leave empty to use same namespace as mcp-client
    
    # IDA Proxy settings - these names are auto-generated from chart fullname
    # The controller will use: {release-name}-ida-proxy, {release-name}-ida-proxy-listen-ports, etc.
    # Leave these empty to use defaults based on Release.Name
    proxyDeployment: ""  # Auto: {fullname}-ida-proxy
    proxyConfigMapPorts: ""  # Auto: {fullname}-ida-proxy-listen-ports
    proxyConfigMapMap: ""  # Auto: {fullname}-ida-proxy-port-map
    
    # MCP Server image
    # For testing, use "nginxdemos/hello" which has a nice visual UI
    # Replace with your actual MCP server image when ready
    mcpServerImageRepo: "nginxdemos/hello"
    mcpServerPort: 80
    # Health check endpoint - nginx hello uses "/" 
    mcpServerHealthPath: "/"
  
  # Bitbucket GitOps Configuration
  # When enabled, the controller updates values in Bitbucket instead of ConfigMaps directly.
  # ArgoCD will sync the changes from Bitbucket and update the ConfigMaps.
  bitbucket:
    enabled: false
    # Bitbucket Server URL (e.g., https://bitbucket.company.com)
    url: ""
    # Bitbucket project key
    project: ""
    # Repository slug (repo name in URL)
    repo: ""
    # Branch to update
    branch: "main"
    # Path to the values file within the repo
    valuesPath: "values.yaml"
    # Bitbucket credentials (username and app password)
    username: ""
    password: ""  # Bitbucket app password or personal access token
    email: "mcp-client@system.local"  # Email for commit author
    # SSL certificate verification (set to false for self-signed certificates)
    verifySSL: true
  
  # Allowed MCP server versions
  allowedVersions: "v1.0.0,v1.1.0,v1.2.0,latest"
  
  # Hostname validation patterns (comma-separated regex)
  # Leave empty to allow all hostnames
  allowedHostnamePatterns: ""
  
  # Port allocation range for proxy ports
  proxyPortMin: 9001
  proxyPortMax: 9100
  
  # IDA port validation range
  idaPortMin: 1024
  idaPortMax: 65535
  
  # MCP Gateway URL (for generating external URLs)
  # This is the externally-accessible URL prefix for MCP servers
  # The proxy port will be appended: {gatewayBaseUrl}:{proxyPort}/
  gatewayBaseUrl: "https://mcp-gateway.company.internal"

# ============================================================
# IDA Proxy Configuration (nginx reverse proxy for IDA workstations)
# ============================================================
idaProxy:
  # Enable IDA Proxy deployment
  enabled: true
  
  # Docker image settings
  image:
    repository: nginx
    tag: alpine
    pullPolicy: IfNotPresent
  
  # Replica count
  replicaCount: 1
  
  # Service configuration
  service:
    type: ClusterIP
  
  # Port allocation range for proxy ports
  # These ports are dynamically allocated to users
  portRange:
    start: 9001
    end: 9100  # Allows 100 concurrent users
  
  # DNS configuration for resolving user workstation hostnames
  dns:
    servers:
      - 10.0.0.53
      - 10.0.0.54
    # Uncomment if using short hostnames without domain
    # searchDomains:
    #   - corp.example.com
    resolverValid: "30s"
    resolverTimeout: "2s"
  
  # Proxy timeouts
  proxy:
    connectTimeout: "2s"
    readTimeout: "60s"
    sendTimeout: "60s"
  
  # Resource limits
  resources:
    limits:
      cpu: 500m
      memory: 256Mi
    requests:
      cpu: 100m
      memory: 128Mi
  
  # Node selector
  nodeSelector: {}
  
  # Tolerations
  tolerations: []
  
  # Affinity
  affinity: {}
  
  # Pod labels
  podLabels: {}
  
  # Pod annotations
  podAnnotations: {}
  
  # Security context
  securityContext:
    runAsNonRoot: false  # nginx needs root to bind to ports
  
  # Pod security context
  podSecurityContext: {}
  
  # Liveness probe
  livenessProbe:
    httpGet:
      path: /health
      port: 8080
    initialDelaySeconds: 10
    periodSeconds: 30
  
  # Readiness probe
  readinessProbe:
    httpGet:
      path: /ready
      port: 8080
    initialDelaySeconds: 5
    periodSeconds: 10
  
  # Port mappings for IDA workstations
  # This section is managed by the K8s controller (via direct update or Bitbucket GitOps)
  # ArgoCD will render ConfigMaps from these mappings
  # Format:
  #   - proxyPort: 9001
  #     upstreamHost: "user1-pc.corp.example.com"
  #     upstreamPort: 13337
  portMappings: []

# External services
external:
  # Redis for caching (optional)
  redis:
    enabled: false
    host: ""
    port: 6379
    database: 0
  
  # Monitoring
  prometheus:
    enabled: false
    port: 9090
    path: /metrics
